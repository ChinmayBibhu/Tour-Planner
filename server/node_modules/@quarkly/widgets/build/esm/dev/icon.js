import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _extends from "@babel/runtime/helpers/esm/extends";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { useRef, useState, useEffect, useCallback } from 'react';
import atomize from '@quarkly/atomize';
import utils from '../utils';
import { Icon } from '../prod';
import { commonProps, pointerEventsCategoryBase, pointerEventsCategoryBaseDefaults } from '../prod/common-props';
var cache = {};
var categories = ['fa', 'bs', 'io', 'md', 'ti', 'go', 'fi', 'gi', 'wi', 'di', 'ai'];

var Wrapper = function Wrapper(_ref) {
  var _ref$icon = _ref.icon,
      icon = _ref$icon === void 0 ? null : _ref$icon,
      category = _ref.category,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["icon", "category", "children"]);

  var iconRef = useRef(null);

  var _useState = useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      forceReload = _useState2[1];

  var setIcon = useCallback(function (icon) {
    iconRef.current = icon;
    forceReload({});
  }, []);
  useEffect(function () {
    if (cache[category]) {
      setIcon(cache[category][icon] || null);
      return;
    }

    setIcon(null);
    var loader = utils.getIcons(category);

    if (loader) {
      loader().then(function (iconSet) {
        cache[category] = iconSet;
        setIcon(iconSet[icon] || null);
      }, function () {});
    }
  }, [category, icon]);
  return React.createElement(Icon, _extends({}, rest, {
    icon: iconRef.current
  }));
};

var IconWrapper = atomize(Wrapper)({
  name: 'Icon',
  effects: {
    hover: ':hover',
    firstChild: ':first-child',
    lastChild: ':last-child',
    onlyChild: ':only-child',
    firstOfType: ':first-of-type',
    lastOfType: ':last-of-type',
    onlyOfType: ':only-of-type',
    before: ':before',
    after: ':after'
  },
  propInfo: _objectSpread({
    size: {
      control: 'input',
      transformer: 'pixel',
      category: 'Main'
    },
    category: {
      control: 'select',
      variants: categories,
      category: 'Main'
    },
    icon: {
      control: 'icon',
      category: 'Main',
      weight: 1
    },
    color: {
      weight: 1,
      control: 'color',
      library: 'color',
      category: 'Main'
    }
  }, commonProps, {}, pointerEventsCategoryBase)
}, _objectSpread({}, Icon.defaultProps, {}, pointerEventsCategoryBaseDefaults));

var getAttrPath = function getAttrPath(attrsPath, attrName) {
  return attrsPath === null || attrsPath === void 0 ? void 0 : attrsPath.find(function (nodePath) {
    return nodePath.isJSXAttribute() && nodePath.get('name.name').node === attrName;
  });
};

var getObjValueNode = function getObjValueNode(propsArray, keyName) {
  return propsArray === null || propsArray === void 0 ? void 0 : propsArray.find(function (nodePath) {
    return checkObjKey(nodePath, keyName);
  });
};

var getBodyVariable = function getBodyVariable(programBody, varName) {
  return programBody.find(function (nodePath) {
    return nodePath.isVariableDeclaration() && nodePath.get('declarations')[0].node.id.name === varName;
  });
};

var checkObjKey = function checkObjKey(nodePath, name) {
  var path = nodePath.get('key');
  return path.isStringLiteral({
    value: name
  }) || path.isIdentifier({
    name: name
  });
};

var getOverrides = function getOverrides(overridesArray, overrideName) {
  var _overridesArray$find, _overridesArray$find$;

  return (_overridesArray$find = overridesArray.find(function (nodePath) {
    return nodePath.isObjectProperty() && checkObjKey(nodePath, overrideName);
  })) === null || _overridesArray$find === void 0 ? void 0 : (_overridesArray$find$ = _overridesArray$find.get('value.properties').find(function (nodePath) {
    return checkObjKey(nodePath, 'props');
  })) === null || _overridesArray$find$ === void 0 ? void 0 : _overridesArray$find$.get('value.properties');
};

var checkVars = function checkVars(icon, category) {
  return icon && category && categories.includes(category);
};

IconWrapper.exportMiddleware = function (path, types) {
  var programPath = path.findParent(function (path) {
    return path.isProgram();
  });
  var programBody = programPath.get('body'); // check jsx attributes

  var attrsPath = path.get('openingElement.attributes');
  var iconAttrPath = getAttrPath(attrsPath, 'icon');
  var catgAttrPath = getAttrPath(attrsPath, 'category');
  var icon = iconAttrPath === null || iconAttrPath === void 0 ? void 0 : iconAttrPath.get('value.value').node;
  var category = catgAttrPath === null || catgAttrPath === void 0 ? void 0 : catgAttrPath.get('value.value').node;

  if (checkVars(icon, category)) {
    // replace jsx icon attribute
    iconAttrPath.get('value').replaceWith(types.JSXExpressionContainer(types.identifier(icon)));
  } else {
    var _attrsPath$find;

    // there is no information in jsx attributes
    // check defaultProps and overrides
    var spreadPath = attrsPath === null || attrsPath === void 0 ? void 0 : (_attrsPath$find = attrsPath.find(function (nodePath) {
      return nodePath.isJSXSpreadAttribute();
    })) === null || _attrsPath$find === void 0 ? void 0 : _attrsPath$find.get('argument');
    if (!spreadPath) return;
    var isDefaultProps = spreadPath.isIdentifier({
      name: 'rest'
    });
    var overrideName = spreadPath.isCallExpression() && spreadPath.get('arguments.0.value').node;
    var propsArray = null;

    if (isDefaultProps) {
      var defaultPropsPath = getBodyVariable(programBody, 'defaultProps');
      propsArray = defaultPropsPath === null || defaultPropsPath === void 0 ? void 0 : defaultPropsPath.get('declarations.0.init.properties');
    } else if (overrideName) {
      var overridesPath = getBodyVariable(programBody, 'overrides');
      propsArray = getOverrides(overridesPath === null || overridesPath === void 0 ? void 0 : overridesPath.get('declarations.0.init.properties'), overrideName);
    }

    if (!propsArray) return;
    var iconNodePath = getObjValueNode(propsArray, 'icon');
    var categoryNodePath = getObjValueNode(propsArray, 'category');
    icon = iconNodePath === null || iconNodePath === void 0 ? void 0 : iconNodePath.get('value.value').node;
    category = categoryNodePath === null || categoryNodePath === void 0 ? void 0 : categoryNodePath.get('value.value').node;
    if (!checkVars(icon, category)) return; // replace object icon value

    iconNodePath.get('value').replaceWith(types.identifier(icon));
  }

  if (!checkVars(icon, category)) return; // add icon import

  var importPath = "react-icons/".concat(category);

  var _programBody$reduce = programBody.reduce(function (acc, nodePath) {
    if (nodePath.isImportDeclaration()) {
      acc.last = nodePath;

      if (nodePath.get('source.value').node === importPath) {
        acc.same = nodePath;
      }
    }

    return acc;
  }, {
    same: null,
    last: null
  }),
      same = _programBody$reduce.same,
      last = _programBody$reduce.last;

  if (!same && !last) return;
  var specifier = types.ImportSpecifier(types.identifier(icon), types.identifier(icon));

  if (!same) {
    var newImport = types.ImportDeclaration([specifier], types.StringLiteral(importPath));
    last.insertAfter(newImport);
  } else {
    var specifiers = same.get('specifiers');
    var isNotExist = specifiers.every(function (nodePath) {
      return nodePath.get('local.name').node !== icon;
    });
    if (isNotExist) same.node.specifiers.push(specifier);
  }
};

IconWrapper.interactive = {
  iconModal: true
};
IconWrapper.defaultContent = "<Icon category='md' icon='MdFace' />";
export default IconWrapper;