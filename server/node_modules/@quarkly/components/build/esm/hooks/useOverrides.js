import _extends from "@babel/runtime/helpers/esm/extends";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React from 'react';
import { merge, isArray, isString } from 'lodash';
import getQAPI from '../utils/getQAPI';
import { Override } from '../';
import createOverrideConfiguration from './override-utils/createOverrideConfiguration';
var JOIN_SEPARATOR = ',';
var PARENT_SEPARATOR = '/';
var PLACEHOLDER_STYLES = {
  width: '100%',
  display: 'none'
};
export var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
export var reIsNumProp = /^\s*\d+\s*$/;
var toArray = React.Children.toArray.bind(React.Children);
/**
 * Функция проверит свойства компонента, на наличие
 * не пустых дочерних значений, и если таких нет,
 * удалит children из свойств
 */

var filterChildrenInProps = function filterChildrenInProps(props) {
  if (isArray(props === null || props === void 0 ? void 0 : props.children) && props.children.filter(function (value) {
    return isArray(value) ? value.length : !!value;
  }).length === 0) {
    delete props.children;
  }
};

var checkPlaceholder = function checkPlaceholder(child) {
  if (!child || !child.props || !child.props.text) return false;
  return child.props.text === 'child placeholder';
};
/**
 * Функция выполняет несколько действий одновременно:
 *
 * - отфильтрует пустые значения из дочерних элементов компонента
 * - найдет все дочерние Overrid'ы и запишет их переопределения слотов
 *   в возвращаемый объект overrides
 * - если у компонента нет "не системных - hasRealChildren" дочерних
 *   элементов и есть дефолтные дочерние элементы из defaultProps,
 *   то примешает их (defaultChildren) к дочерним элементам компонента
 * - вернет собранные overrid'ы и обработанные дочерние элементы
 */


var filterChildren = function filterChildren(componentChildren, defaultProps) {
  var defaultChildren = defaultProps === null || defaultProps === void 0 ? void 0 : defaultProps.children;
  var overrides = {};
  var hasRealChildren = false;
  var children = toArray(componentChildren).filter(function (child) {
    var _child$props;

    var isDNDPlaceholder = checkPlaceholder(child);
    var isEmpty = !child;
    var isOverride = !!(child === null || child === void 0 ? void 0 : (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.slot); // skip placeholder

    if (isDNDPlaceholder) return true; // remove empty children

    if (isEmpty) return false; // extract data from overrides

    if (isOverride) {
      var _child$props2 = child.props,
          slot = _child$props2.slot,
          rest = _objectWithoutProperties(_child$props2, ["slot"]);

      filterChildrenInProps(rest);

      if (slot) {
        if (!overrides[slot]) {
          overrides[slot] = {};
        }

        merge(overrides[slot], rest);
      }

      return true;
    } // save the rest of the children


    hasRealChildren = true;
    return true;
  });

  if (!hasRealChildren && defaultChildren) {
    children.push.apply(children, _toConsumableArray(toArray(defaultChildren)));
  }

  return {
    overrides: overrides,
    children: children
  };
};
/**
 * Для каждого ключа из keys смешиваем свойства
 * overrid'od из исходного кода компонента overrides/componentOverrides
 * cо свойствами из оверайдов извлеченных из дочерних элементов
 * компонента
 *
 * fromSourceCode - оверайды определенные в компоненте
 * fromChildren - оверайды определенные в дочерних элементах компонента
 */


var mergeOverridesByKeys = function mergeOverridesByKeys(keys, fromSourceCode, fromChildren) {
  return keys.reduce(function (acc, key) {
    return _objectSpread({}, acc, {}, mergeOverrideProps(fromSourceCode[key], fromChildren[key]));
  }, {});
};

var mergeOverrideProps = function mergeOverrideProps(fromSourceCode, propsFromChildren) {
  var propsFromSourceCode = (fromSourceCode === null || fromSourceCode === void 0 ? void 0 : fromSourceCode.props) || {};
  var overridesFromSourceCode = (fromSourceCode === null || fromSourceCode === void 0 ? void 0 : fromSourceCode.overrides) || {}; // convert source code overrides to react components

  var childrenFromOverrides = getOverrideChildren(overridesFromSourceCode) || [];
  var hasChildren = toArray(propsFromChildren === null || propsFromChildren === void 0 ? void 0 : propsFromChildren.children).some(function (v) {
    return v;
  });
  var childrenFromProps = hasChildren ? propsFromChildren.children : propsFromSourceCode.children; // wrap with array

  if (!Array.isArray(childrenFromProps)) {
    childrenFromProps = [childrenFromProps];
  } // add keys


  childrenFromProps = childrenFromProps.map(function (child, index) {
    var _child;

    if (React.isValidElement(child) && ((_child = child) === null || _child === void 0 ? void 0 : _child.key) === null) {
      child = React.cloneElement(child, {
        key: index
      });
    }

    return child;
  });

  var props = _objectSpread({}, propsFromSourceCode, {}, propsFromChildren, {
    children: [].concat(_toConsumableArray(childrenFromOverrides), _toConsumableArray(childrenFromProps)).filter(function (v) {
      return v;
    })
  }); // Мы не передаем kind react-компонентам Override, чтоб они не могли
  // переопределить kind тем компонентам которым передают новые свойства.
  // В результирующей верстке (html) Overrid'ы все равно никак не отображаются
  // и служат только инструментом переопределения свойств слотам


  if ((fromSourceCode === null || fromSourceCode === void 0 ? void 0 : fromSourceCode.kind) && fromSourceCode.kind !== 'Override') {
    props['data-qkind'] = fromSourceCode.kind;
  }

  if (!props.children.length) {
    delete props.children;
  }

  return props;
};
/**
 * Просматривает overrides/componentOverrides компонента
 * и рендерит эти узлы, если они есть. Рендеринг выполняется
 * рекурсивно
 */


var getOverrideChildren = function getOverrideChildren(overrides) {
  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (!overrides) return null;
  return Object.entries(overrides).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        _ref2$ = _ref2[1],
        props = _ref2$.props,
        overrides = _ref2$.overrides;

    var _ref3 = props || {},
        _ref3$children = _ref3.children,
        children = _ref3$children === void 0 ? null : _ref3$children,
        rest = _objectWithoutProperties(_ref3, ["children"]);
    /**
     * Необходимо привести дочерние элементы оверрайдов в единную сущность в виде массива,
     * иначе произойдет некорректный мердж двух списков и реакт при исполнении функции toArray уйдёт в рекурсию
     */


    var overrideChildren = getOverrideChildren(overrides, level + 1) || [];
    var normalizedChildren = children || [];

    if (!Array.isArray(children)) {
      normalizedChildren = [normalizedChildren];
    }

    return /*#__PURE__*/React.createElement(Override, _extends({
      key: "".concat(level, "-").concat(key),
      slot: key
    }, rest), [].concat(_toConsumableArray(overrideChildren), _toConsumableArray(normalizedChildren)));
  });
};

export var useOverrides = function useOverrides(componentProps, componentOverrides, componentDefaultProps) {
  var componentChildren = componentProps.children,
      restProps = _objectWithoutProperties(componentProps, ["children"]);

  var _filterChildren = filterChildren(componentChildren, componentDefaultProps),
      overridesFromChildren = _filterChildren.overrides,
      filteredChildren = _filterChildren.children;

  var override = function override() {
    for (var _len = arguments.length, overrideKeys = new Array(_len), _key = 0; _key < _len; _key++) {
      overrideKeys[_key] = arguments[_key];
    }

    var length = overrideKeys.length;

    if (length === 0) {
      console.warn('override function call should not be without params');
      return {};
    }

    var _createOverrideConfig = createOverrideConfiguration(length <= 1 ? {} : overrideKeys[length - 1]),
        defaultKey = _createOverrideConfig.defaultKey;

    for (var _i = 0, _overrideKeys = overrideKeys; _i < _overrideKeys.length; _i++) {
      var key = _overrideKeys[_i];

      if (isString(key) && (reIsDeepProp.test(key) || reIsNumProp.test(key))) {
        throw new Error("\"".concat(key, "\" isn't allowed as an override key"));
      }
    }

    var joinedKeys = overrideKeys.filter(function (v) {
      return isString(v) && v;
    }).join(JOIN_SEPARATOR);
    var parentOverrideKey = restProps['data-qoverride'];
    var parentComponentId = restProps['data-qparent'];
    var componentId = restProps['data-qid'];
    var resultKey = joinedKeys; // зачем создавать такой ключ, для qparent? какую роль он потом будет нести?

    if (parentOverrideKey) {
      resultKey = parentOverrideKey + PARENT_SEPARATOR + resultKey;
    }

    return _objectSpread({
      'data-qparent': parentComponentId || componentId,
      'data-qoverride': resultKey
    }, mergeOverridesByKeys(overrideKeys, componentOverrides, overridesFromChildren), {
      'data-qoverride-default': defaultKey,
      'data-propinfo-id': undefined
    });
  };

  var ChildPlaceholder = React.useMemo(function () {
    return function (_ref4) {
      var slot = _ref4.slot;
      var qapi = getQAPI();

      if (!isString(slot) || reIsDeepProp.test(slot) || reIsNumProp.test(slot)) {
        throw new Error("\"".concat(slot, "\" isn't allowed as a ChildPlaceholder slot"));
      }

      var slotData = override(slot);
      var childPlaceholderKey = slot;
      var parentOverrideKey = restProps['data-qoverride'];

      if (parentOverrideKey) {
        childPlaceholderKey = parentOverrideKey + PARENT_SEPARATOR + childPlaceholderKey;
      }

      return /*#__PURE__*/React.createElement(React.Fragment, {
        key: "".concat(childPlaceholderKey, "-fragment")
      }, qapi.mode !== 'production' && /*#__PURE__*/React.createElement("div", {
        key: "div-placeholder-".concat(childPlaceholderKey),
        "data-child-placeholder": childPlaceholderKey,
        "data-child-placeholder-parent": restProps['data-qparent'] || restProps['data-qid'],
        style: PLACEHOLDER_STYLES
      }), slotData.children);
    };
  }, [override]);
  /*
   * TODO: it creates unnecessary overrides
   * It needs to filter out existing calls: override('key')
   */

  var overridesFromCode = getOverrideChildren(componentOverrides) || [];
  return {
    override: override,
    children: [].concat(_toConsumableArray(overridesFromCode), _toConsumableArray(filteredChildren)),
    rest: restProps,
    ChildPlaceholder: ChildPlaceholder
  };
};